diff --git a/configure.ac b/configure.ac
index ae756038e7d..bb322d44eb1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -571,6 +571,10 @@ On by default on macOS.])],[],[with_ns=maybe])
 OPTION_DEFAULT_OFF([w32], [use native MS Windows GUI in a Cygwin build])
 OPTION_DEFAULT_OFF([pgtk], [use GTK to support window systems other than X])
 
+OPTION_DEFAULT_ON([w32-ime], [don't compile with W32-IME support])
+OPTION_DEFAULT_ON([reconversion], [don't compile with RECONVERSION support])
+OPTION_DEFAULT_ON([documentfeed], [don't compile with DOCUMENTFEED support])
+
 OPTION_DEFAULT_ON([gpm],[don't use -lgpm for mouse support on a GNU/Linux console])
 OPTION_DEFAULT_ON([dbus],[don't compile with D-Bus support])
 AC_ARG_WITH([gconf],[AS_HELP_STRING([--with-gconf],
@@ -7656,6 +7660,42 @@ else
   HAVE_GMP=no
 fi
 
+USE_W32_IME=no
+if test "${HAVE_W32}" = "yes"; then
+  if test "${with_w32_ime}" != "no"; then
+    USE_W32_IME=yes
+    AC_DEFINE(USE_W32_IME, 1, [Define to support W32-IME.])
+
+    RECONVERSION=no
+    if test "${with_reconversion}" != "no"; then
+      AC_CACHE_CHECK([whether RECONVERTSTRING is declared],
+        emacs_cv_have_reconvertstring,
+        [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <windows.h>
+#include <imm.h>]], [[RECONVERTSTRING]])],
+        emacs_cv_have_reconvertstring=yes, emacs_cv_have_reconvertstring=no)])
+      if test "$emacs_cv_have_reconvertstring" = "yes"; then
+        RECONVERSION=yes
+        AC_DEFINE(RECONVERSION, 1, [Define to support RECONVERSION.])
+        AC_DEFINE(HAVE_RECONVERTSTRING, 1, [Define to 1 if you have RECONVERTSTRING.])
+
+        DOCUMENTFEED=no
+        if test "${with_documentfeed}" != "no"; then
+          AC_CHECK_DECL(IMR_DOCUMENTFEED, HAVE_IMR_DOCUMENTFEED=yes,
+            HAVE_IMR_DOCUMENTFEED=no,[[
+#include <windows.h>
+#include <imm.h>]])
+          if test "$ac_cv_have_decl_IMR_DOCUMENTFEED" = "yes"; then
+            DOCUMENTFEED=yes
+            AC_DEFINE(DOCUMENTFEED, 1, [Define to support DOCUMENTFEED.])
+            AC_DEFINE(HAVE_IMR_DOCUMENTFEED, 1, [Define to 1 if you have IMR_DOCUMENTFEED.])
+          fi
+        fi
+      fi
+    fi
+  fi
+fi
+
 emacs_standard_dirs='Standard dirs'
 AS_ECHO(["
 Configured for '${canonical}'.
diff --git a/lisp/international/smart-ime.el b/lisp/international/smart-ime.el
new file mode 100644
index 00000000000..eaa5eaf920f
--- /dev/null
+++ b/lisp/international/smart-ime.el
@@ -0,0 +1,177 @@
+;;; smart-ime.el - smart Input Method -*- lexical-binding: t -*-
+;;
+;; Copyright (C) 2011 HIROSHI OOTA
+
+;; Author: HIROSHI OOTA
+;; Keywords: convenience
+
+;; This program is free software; you can redistribute it and/or
+;; modify it under the terms of the GNU General Public License as
+;; published by the Free Software Foundation; either version 3, or (at
+;; your option) any later version.
+
+;; This program is distributed in the hope that it will be useful, but
+;; WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;; General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU Emacs; see the file COPYING.  If not, write to the
+;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+;; Boston, MA 02110-1301, USA.
+
+;;; Commentary:
+;;
+;; smart-im frees you from the frustration about IM.
+;; It disables an IM automatically according to a situation.
+
+;;; Install:
+;; Put this file into load-path'ed directory, and byte compile it if
+;; desired.  And put the following expression into your ~/.emacs.
+;;
+;;     (require 'smart-ime)
+
+;; Todo:
+
+;;; Code:
+
+;; variable
+(defvar sime-saved-input-method nil)
+(make-variable-buffer-local 'sime-saved-input-method)
+(set-default 'sime-saved-input-method nil)
+
+(defun sime-activate-input-method ()
+  (setq sime-saved-input-method (list current-input-method))
+  (deactivate-input-method))
+(defun sime-inactivate-input-method ()
+  (when sime-saved-input-method
+    (activate-input-method (car sime-saved-input-method))
+    (setq sime-saved-input-method nil)))
+
+;;
+;; minibuffer
+(add-hook 'minibuffer-setup-hook 'sime-activate-input-method)
+(add-hook 'minibuffer-exit-hook 'sime-inactivate-input-method)
+;;
+;; incremental search
+(add-hook 'isearch-mode-hook 'sime-activate-input-method)
+(add-hook 'isearch-mode-end-hook 'sime-inactivate-input-method)
+
+;;
+;; query-replace, query-replace-regexp, query-replace-regexp-eval ...
+(advice-add 'perform-replace :around
+            (lambda (orig-fun &rest args)
+              (let ((im current-input-method)
+		    retval)
+                (if (or (not im)
+	                (not (nth 2 args)))
+	            (apply orig-fun args)
+                  (deactivate-input-method)
+                  (setq retval (apply orig-fun args))
+                  (activate-input-method im)
+		  retval))))
+
+;;
+;; read-passwd
+(defvar sime-ad-toggle-ime-mapped-key-list)
+(advice-add 'read-passwd :around
+            (lambda (orig-fun &rest args)
+              (let ((im current-input-method)
+		    retval)
+                (setq sime-ad-toggle-ime-mapped-key-list nil)
+                (dolist (k (where-is-internal
+                            'toggle-input-method overriding-local-map nil nil
+                            (command-remapping 'toggle-input-method)))
+                  (when (integerp (aref k 0))
+	            (setq sime-ad-toggle-ime-mapped-key-list
+	                  (cons (aref k 0) sime-ad-toggle-ime-mapped-key-list))))
+
+		(advice-add 'read-key :around #'sime-ad-read-key)
+                (deactivate-input-method)
+                (setq retval (apply orig-fun args))
+                (activate-input-method im)
+		(advice-remove 'read-key #'sime-ad-read-key)
+		retval)))
+
+(defun sime-ad-read-key (orig-fun &rest args)
+  (let ((flag t)
+	(msg (current-message))
+	retval)
+    (while flag
+      (setq retval (apply orig-fun args))
+      (if (not (memq retval
+                     sime-ad-toggle-ime-mapped-key-list))
+	  (setq flag nil)
+	(toggle-input-method)
+	(message msg)))
+    retval))
+
+;;
+;; universal-argument
+(advice-add 'universal-argument :before
+            (lambda ()
+              (setq sime-saved-input-method
+                    (or sime-saved-input-method
+                        (list current-input-method)))
+              (deactivate-input-method)))
+
+(defun universal-argument--mode ()
+  (setq sime-saved-input-method
+	(or sime-saved-input-method
+	    (list current-input-method)))
+  (deactivate-input-method)
+  (prefix-command-update)
+  (set-transient-map universal-argument-map #'sime-inactivate-input-method))
+
+;; a keyboard which has no KANJI-KEY
+;; entering/leaving KANJI-mode key-sequence is <kanji><M-kanji>
+;; then we should pass prefix-arg to next command.
+(global-set-key
+  [M-kanji]
+  #'(lambda (arg)
+      (interactive "P")
+      (setq prefix-arg arg)))
+
+;;
+;; others
+(defmacro wrap-function-to-control-input-method (fcn)
+  `(advice-add ,fcn :around
+               (lambda (orig-fun &rest args)
+                 (let ((im current-input-method)
+		       retval)
+                   (deactivate-input-method)
+                   (setq retval (apply orig-fun args))
+                   (activate-input-method im)
+		   retval))))
+
+(wrap-function-to-control-input-method 'map-y-or-n-p)
+(wrap-function-to-control-input-method 'y-or-n-p)
+(wrap-function-to-control-input-method 'read-key-sequence)
+
+;; disable W32-IME control during processing the timer handler
+(advice-add 'timer-event-handler :around
+            (lambda (orig-fun &rest args)
+              (let ((w32-ime-buffer-switch-p nil))
+                (apply orig-fun args))))
+
+;; turn IME off when specifying a register
+(eval-when-compile (require 'cl-macs))
+(declare-function saved-read-key "register" (&optional prompt))
+(declare-function register-read-with-preview-with-ime-off "register" (orig-fun &rest args))
+(with-eval-after-load "register"
+  (fset 'saved-read-key (symbol-function 'read-key))
+  (defun read-key-with-ime-off (&optional prompt)
+    (let ((im current-input-method)
+	  (key))
+      (deactivate-input-method)
+      (setq key (saved-read-key prompt))
+      (activate-input-method im)
+      key))
+  (defun register-read-with-preview-with-ime-off (orig-fun &rest args)
+    (cl-letf (((symbol-function 'read-key)
+	       (symbol-function 'read-key-with-ime-off)))
+      (apply orig-fun args)))
+  (advice-add 'register-read-with-preview :around #'register-read-with-preview-with-ime-off))
+
+(provide 'smart-ime)
+;; -*- mode: Emacs-Lisp; coding: euc-jp-unix -*-
diff --git a/lisp/international/w32-ime.el b/lisp/international/w32-ime.el
new file mode 100644
index 00000000000..66d51b800d6
--- /dev/null
+++ b/lisp/international/w32-ime.el
@@ -0,0 +1,202 @@
+;;;;; w32-ime.el ---- Meadow features for NTEmacs. -*- lexical-binding: t -*-
+;;
+;;   Author H.Miyashita
+;;
+;;;;;
+
+(defgroup W32-IME nil
+  "w32-ime"
+  :group 'emacs)
+
+(defvar w32-last-selection nil
+  "It is stored the last data from Emacs.")
+
+;----------
+
+(defvar w32-ime-on-hook nil
+  "Functions to eval when IME is turned on at least.
+Even if IME state is not changed, these functiona are maybe called.")
+(defvar w32-ime-off-hook nil
+  "Functions to eval when IME is turned off at least.
+Even if IME state is not changed, these functiona are maybe called.")
+(defvar w32-ime-buffer-switch-p t
+  "If this variable is nil, IME control when buffer is switched is disabled.")
+(defvar w32-ime-show-mode-line t
+  "When t, mode line indicates IME state.")
+(defvar w32-ime-mode-line-state-indicator "[O]"
+  "This is shown at the mode line. It is regarded as state of ime.")
+(make-variable-buffer-local 'w32-ime-mode-line-state-indicator)
+(put 'w32-ime-mode-line-state-indicator 'permanent-local t)
+(defvar w32-ime-mode-line-state-indicator-list '("-" "[|]" "[O]")
+  "List of IME state indicator string.")
+(defvar w32-ime-mode-line-format-original nil
+  "Original mode line format.")
+
+;;
+;; Section: IME
+;;
+
+;; ;; This is temporal solution.  In the future, we will prepare
+;; ;; dynamic configuration.
+;; (defvar w32-ime-coding-system-language-environment-alist
+;;   '(("Japanese" . japanese-shift-jis)
+;;     ("Chinese-GB" . chinese-iso-8bit)
+;;     ("Chinese-BIG5" . chinese-big5)
+;;     ("Korean" . korean-iso-8bit)))
+
+;;
+;; IME state indicator
+;;
+(global-set-key [kanji] 'ignore)
+(global-set-key [compend] 'ignore)
+
+(defun wrap-function-to-control-ime
+  (function interactive-p interactive-arg &optional suffix)
+  "Wrap FUNCTION, and IME control is enabled when FUNCTION is called.
+An original function is saved to FUNCTION-SUFFIX when suffix is string.
+If SUFFIX is nil, \"-original\" is added. "
+  (let ((original-function
+	 (intern (concat (symbol-name function)
+			 (if suffix suffix "-original")))))
+    (cond
+     ((not (fboundp original-function))
+      (fset original-function
+	    (symbol-function function))
+      (fset function
+	    (list
+	     'lambda '(&rest arguments)
+	     (when interactive-p
+	       (list 'interactive interactive-arg))
+	     `(cond
+		((and (w32-get-ime-open-status)
+		      (equal current-input-method "W32-IME"))
+		 (ime-force-off)
+		 (unwind-protect
+		     (apply ',original-function arguments)
+		   (when (and (not (w32-get-ime-open-status))
+			      (equal current-input-method "W32-IME"))
+		     (ime-force-on))))
+		(t
+		 (apply ',original-function arguments)))))))))
+
+(defvar w32-ime-toroku-region-yomigana nil
+  "* if this variable is string, toroku-region regard this value as yomigana.")
+
+(defun w32-ime-toroku-region (begin end)
+  (interactive "r")
+  (let ((string (buffer-substring begin end))
+	(w32-ime-buffer-switch-p nil)
+	(reading w32-ime-toroku-region-yomigana))
+    (unless (stringp reading)
+      (w32-set-ime-mode 'hiragana)
+      (setq reading
+	    (read-multilingual-string
+            (format "Input reading of \"%s\": " string) nil "W32-IME")))
+    (w32-ime-register-word-dialog reading string)))
+
+;; for IME management system.
+
+(defun w32-ime-sync-state (window)
+  (when w32-ime-buffer-switch-p
+    (with-current-buffer (window-buffer window)
+      (let* ((ime-state (w32-get-ime-open-status)))
+	(cond
+	 ((and (not ime-state)
+	       (equal current-input-method "W32-IME"))
+	  (ime-force-on nil)
+	  (run-hooks 'w32-ime-on-hook))
+	 ((and ime-state
+	       (not (equal current-input-method "W32-IME")))
+;;;	  (when (= (w32-ime-undetermined-string-length) 0)
+	  (ime-force-off nil)
+	  (run-hooks 'w32-ime-off-hook)))))))
+
+(defun w32-ime-set-selected-window-buffer-hook (oldbuf newwin newbuf)
+  (ignore oldbuf newwin newbuf)
+  (w32-ime-sync-state newwin))
+
+(defun w32-ime-select-window-hook (old new)
+  (ignore old)
+  (w32-ime-sync-state new))
+
+(defun w32-ime-mode-line-update ()
+  (cond
+   (w32-ime-show-mode-line
+    (unless (window-minibuffer-p (selected-window))
+      (setq w32-ime-mode-line-state-indicator
+	    (nth (if (w32-get-ime-open-status) 1 2)
+		 w32-ime-mode-line-state-indicator-list))))
+   (t
+    (setq w32-ime-mode-line-state-indicator
+	  (nth 0 w32-ime-mode-line-state-indicator-list))))
+  (force-mode-line-update))
+
+(defun w32-ime-init-mode-line-display ()
+  (unless (member 'w32-ime-mode-line-state-indicator mode-line-format)
+    (setq w32-ime-mode-line-format-original
+	  (default-value 'mode-line-format))
+    (if (and (stringp (car mode-line-format))
+	     (string= (car mode-line-format) "-"))
+	(setq-default mode-line-format
+		      (cons ""
+			    (cons 'w32-ime-mode-line-state-indicator
+				  (cdr mode-line-format))))
+      (setq-default mode-line-format
+		    (cons ""
+			  (cons 'w32-ime-mode-line-state-indicator
+				mode-line-format))))
+    (force-mode-line-update t)))
+
+(defun w32-ime-initialize ()
+   (when (and (eq system-type 'windows-nt)
+	      (eq window-system 'w32)
+	      (featurep 'w32-ime))
+     (w32-ime-init-mode-line-display)
+     (w32-ime-mode-line-update)
+     (add-hook 'select-window-functions
+	       'w32-ime-select-window-hook)
+     (add-hook 'set-selected-window-buffer-functions
+	       'w32-ime-set-selected-window-buffer-hook)
+     (define-key global-map [kanji] 'toggle-input-method)))
+;;     (set-keyboard-coding-system 'utf-8)))
+
+(defun w32-ime-uninitialize ()
+  (when (and (eq system-type 'windows-nt)
+	     (eq window-system 'w32)
+	     (featurep 'w32-ime))
+    (setq-default mode-line-format
+		  w32-ime-mode-line-format-original)
+    (force-mode-line-update t)
+    (remove-hook 'select-window-functions
+		 'w32-ime-select-window-hook)
+    (remove-hook 'set-selected-window-buffer-functions
+		 'w32-ime-set-selected-window-buffer-hook)
+    (define-key global-map [kanji] 'ignore)))
+
+(defun w32-ime-exit-from-minibuffer ()
+  (deactivate-input-method)
+  (when (<= (minibuffer-depth) 1)
+    (remove-hook 'minibuffer-exit-hook 'w32-ime-exit-from-minibuffer)))
+
+(defun w32-ime-state-switch (&optional arg)
+  (if arg
+      (progn
+	(setq deactivate-current-input-method-function
+	      'w32-ime-state-switch)
+	(run-hooks 'input-method-activate-hook)
+	(run-hooks 'w32-ime-on-hook)
+	(setq describe-current-input-method-function nil)
+	(when (eq (selected-window) (minibuffer-window))
+	  (add-hook 'minibuffer-exit-hook 'w32-ime-exit-from-minibuffer))
+	(ime-force-on))
+    (setq current-input-method nil)
+    (run-hooks 'input-method-inactivate-hook)
+    (run-hooks 'w32-ime-off-hook)
+    (setq describe-current-input-method-function nil)
+    (ime-force-off))
+  (w32-ime-mode-line-update))
+
+(register-input-method "W32-IME" "Japanese" 'w32-ime-state-switch ""
+		       "W32 System IME")
+
+(provide 'w32-ime)
diff --git a/lisp/ldefs-boot.el b/lisp/ldefs-boot.el
index ab791da3271..d08051d59fe 100644
--- a/lisp/ldefs-boot.el
+++ b/lisp/ldefs-boot.el
@@ -29641,6 +29641,14 @@ twice for the others.
 (fn ARG)" t)
 (register-definition-prefixes "skeleton" '("skeleton-"))
 
+
+;;;### (autoloads nil "smart-ime" "international/smart-ime.el" (0
+;;;;;;  0 0 0))
+;;; Generated autoloads from international/smart-ime.el
+
+(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "smart-ime" '("wrap-function-to-control-input-method" "universal-argument--mode" "sime-")))
+
+;;;***
 
 ;;; Generated autoloads from vc/smerge-mode.el
 
@@ -36733,6 +36741,15 @@ Visual-Wrap-Prefix mode.
 (register-definition-prefixes "w32-fns" '("w32-"))
 
 
+;;;### (autoloads nil "w32-ime" "international/w32-ime.el" (0 0 0
+;;;;;;  0))
+;;; Generated autoloads from international/w32-ime.el
+
+(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "w32-ime" '("wrap-function-to-control-ime" "w32-")))
+
+;;;***
+
+;;;### (autoloads nil "w32-vars" "w32-vars.el" (0 0 0 0))
 ;;; Generated autoloads from w32-vars.el
 
 (register-definition-prefixes "w32-vars" '("w32-"))
diff --git a/lisp/loadup.el b/lisp/loadup.el
index 6d1e13f44bf..af9764f0828 100644
--- a/lisp/loadup.el
+++ b/lisp/loadup.el
@@ -341,6 +341,7 @@
       (load "w32-vars")
       (load "term/w32-win")
       (load "disp-table")
+      (load "international/w32-ime")
       (when (eq system-type 'windows-nt)
         (load "w32-fns")
         (load "ls-lisp")
diff --git a/src/frame.c b/src/frame.c
index 7f4bf274ad9..4a40f40fee7 100644
--- a/src/frame.c
+++ b/src/frame.c
@@ -1477,8 +1477,24 @@ affects all frames on the same terminal device.  */)
 
    The value of NORECORD is passed as argument to Fselect_window.  */
 
+#ifdef USE_W32_IME
+Lisp_Object
+do_switch_frame_0 (Lisp_Object frame, int track, int for_deletion, Lisp_Object norecord);
+Lisp_Object
+do_switch_frame (Lisp_Object frame, int track, int for_deletion, Lisp_Object norecord)
+{
+  specpdl_ref count = SPECPDL_INDEX ();
+
+  specbind (Qw32_ime_buffer_switch_p, Qnil);
+  do_switch_frame_0 (frame, track, for_deletion, norecord);
+  unbind_to (count, Qnil);
+}
+Lisp_Object
+do_switch_frame_0 (Lisp_Object frame, int track, int for_deletion, Lisp_Object norecord)
+#else  /* !USE_W32_IME */
 Lisp_Object
 do_switch_frame (Lisp_Object frame, int track, int for_deletion, Lisp_Object norecord)
+#endif /* !USE_W32_IME */
 {
   struct frame *sf = SELECTED_FRAME (), *f;
 
@@ -4040,6 +4056,9 @@ static const struct frame_parm_table frame_parms[] =
   {"fullscreen",                SYMBOL_INDEX (Qfullscreen)},
   {"font-backend",		SYMBOL_INDEX (Qfont_backend)},
   {"alpha",			SYMBOL_INDEX (Qalpha)},
+#ifdef USE_W32_IME
+  {"ime-font",			SYMBOL_INDEX (Qime_font)},
+#endif /* USE_W32_IME */
   {"sticky",			SYMBOL_INDEX (Qsticky)},
   {"tool-bar-position",		SYMBOL_INDEX (Qtool_bar_position)},
   {"inhibit-double-buffering",  SYMBOL_INDEX (Qinhibit_double_buffering)},
diff --git a/src/keyboard.c b/src/keyboard.c
index c75e80d2a05..8a355303162 100644
--- a/src/keyboard.c
+++ b/src/keyboard.c
@@ -364,6 +364,11 @@ static struct timespec timer_idleness_start_time;
 
 static struct timespec timer_last_idleness_start_time;
 
+#ifdef USE_W32_IME
+static Lisp_Object IME_command_off_flag;
+static Lisp_Object IME_interrupt_flag;
+#endif /* USE_W32_IME */
+
 /* Predefined strings for core device names.  */
 
 static Lisp_Object virtual_core_pointer_name;
@@ -1334,6 +1339,14 @@ command_loop_1 (void)
   this_command_key_count = 0;
   this_single_command_key_start = 0;
 
+#ifdef USE_W32_IME
+  if (!NILP (IME_command_off_flag))
+    {
+      Fime_force_on (Qnil);
+      IME_command_off_flag = Qnil;
+    }
+#endif /* USE_W32_IME */
+
   if (NILP (Vmemory_full))
     {
       /* Make sure this hook runs after commands that get errors and
@@ -5145,7 +5158,11 @@ const char *const lispy_function_keys[] =
     "junja",          /* VK_JUNJA          0x17 */
     "final",          /* VK_FINAL          0x18 */
     "kanji",          /* VK_KANJI/VK_HANJA 0x19 */
+#ifdef USE_W32_IME
+    "compend",        /* VK_COMPEND        0x1A */
+#else  /* !USE_W32_IME */
     0,                /*    0x1A                */
+#endif /* !USE_W32_IME */
     "escape",         /* VK_ESCAPE         0x1B */
     "convert",        /* VK_CONVERT        0x1C */
     "non-convert",    /* VK_NONCONVERT     0x1D */
@@ -10424,6 +10441,19 @@ read_key_sequence (Lisp_Object *keybuf, Lisp_Object prompt,
 {
   specpdl_ref count = SPECPDL_INDEX ();
 
+#ifdef USE_W32_IME
+  Lisp_Object IME_command_loop_flag = Qnil;
+  IME_command_off_flag = Qnil;
+  if (!NILP (IME_interrupt_flag))
+    {
+      Lisp_Object func = intern ("sime-inactivate-input-method");
+
+      if (!NILP (Ffboundp (func)))
+	call0 (func);
+      IME_interrupt_flag = Qnil;
+    }
+#endif /* USE_W32_IME */
+
   /* How many keys there are in the current key sequence.  */
   int t;
 
@@ -10559,6 +10589,12 @@ read_key_sequence (Lisp_Object *keybuf, Lisp_Object prompt,
      keybuf[0..mock_input] holds the sequence we should reread.  */
  replay_sequence:
 
+#ifdef USE_W32_IME
+  /* If key sequences are to replay, IME_loop_flag should not be set.
+     Because event has never been occured. */
+  IME_command_loop_flag = Qnil;
+#endif /* USE_W32_IME */
+
   starting_buffer = current_buffer;
   first_unbound = READ_KEY_ELTS + 1;
   Lisp_Object first_event = mock_input > 0 ? keybuf[0] : Qnil;
@@ -10653,6 +10689,16 @@ read_key_sequence (Lisp_Object *keybuf, Lisp_Object prompt,
 	  goto replay_sequence;
 	}
 
+#ifdef USE_W32_IME
+      if (!NILP (IME_command_loop_flag) && NILP (IME_command_off_flag))
+	{
+	  IME_command_off_flag = Fw32_get_ime_open_status ();
+	  if (!NILP (IME_command_off_flag))
+	    Fime_force_off (Qnil);
+	}
+      IME_command_loop_flag = Qt;
+#endif	/* USE_W32_IME */
+
       if (t >= READ_KEY_ELTS)
 	error ("Key sequence too long");
 
@@ -10820,6 +10866,10 @@ read_key_sequence (Lisp_Object *keybuf, Lisp_Object prompt,
 	     Just return -1.  */
 	  if (EQ (key, Qt))
 	    {
+#ifdef USE_W32_IME
+	      if (!NILP (IME_command_off_flag))
+		Fime_force_on (Qnil);
+#endif /* USE_W32_IME */
 	      unbind_to (count, Qnil);
 	      return -1;
 	    }
@@ -11385,6 +11435,11 @@ read_key_sequence (Lisp_Object *keybuf, Lisp_Object prompt,
     ? Fcommand_remapping (read_key_sequence_cmd, Qnil, Qnil)
     : Qnil;
 
+#ifdef USE_W32_IME
+  if (!NILP (IME_command_off_flag))
+    Fime_force_on (Qnil);
+#endif /* USE_W32_IME */
+
   unread_switch_frame = delayed_switch_frame;
   unbind_to (count, Qnil);
 
@@ -12231,6 +12286,10 @@ quit_throw_to_read_char (bool from_signal)
 
   Vunread_command_events = Qnil;
 
+#ifdef USE_W32_IME
+  IME_interrupt_flag = Qt;
+#endif /* USE_W32_IME */
+
   if (FRAMEP (internal_last_event_frame)
       && !EQ (internal_last_event_frame, selected_frame))
     do_switch_frame (make_lispy_switch_frame (internal_last_event_frame),
@@ -12680,6 +12739,10 @@ init_keyboard (void)
   input_pending = false;
   interrupt_input_blocked = 0;
   pending_signals = false;
+#ifdef USE_W32_IME
+  IME_command_off_flag = Qnil;
+  IME_interrupt_flag = Qnil;
+#endif /* USE_W32_IME */
 
   virtual_core_pointer_name = build_string ("Virtual core pointer");
   virtual_core_keyboard_name = build_string ("Virtual core keyboard");
diff --git a/src/w32fns.c b/src/w32fns.c
index 4c2f18abd08..28588d20180 100644
--- a/src/w32fns.c
+++ b/src/w32fns.c
@@ -81,6 +81,11 @@ typedef enum _WTS_VIRTUAL_CLASS {
 #include <imm.h>
 #include <windowsx.h>
 
+#ifdef USE_W32_IME
+#include "fontset.h"
+#include "w32font.h"
+#endif /* USE_W32_IME */
+
 /*
   Internal/undocumented constants for Windows Dark mode.
   See: https://github.com/microsoft/WindowsAppSDK/issues/41
@@ -99,14 +104,75 @@ typedef enum _WTS_VIRTUAL_CLASS {
 #define FOF_NO_CONNECTED_ELEMENTS 0x2000
 #endif
 
+#ifdef IME_UNICODE
+#define __T(x) L ## x
+#define _T(x) __T(x)
+#else
+#define _T(x) x
+#endif
+
+void syms_of_w32fns (void);
+void globals_of_w32fns (void);
+
+extern void free_frame_menubar (struct frame *);
 extern int w32_console_toggle_lock_key (int, Lisp_Object);
 extern void w32_menu_display_help (HWND, HMENU, UINT, UINT);
 extern void w32_free_menu_strings (HWND);
 
+#if defined (RECONVERSION) || defined (DOCUMENTFEED)
+#ifdef IME_UNICODE
+#define CHRSZ sizeof(short)
+#else
+#define CHRSZ sizeof(char)
+#endif
+#endif
+
+#if defined (RECONVERSION)
+#define RECONV_LENG 100
+#define DOCFEED_LENG 100
+static LRESULT w32_get_ime_reconversion_string (HWND, RECONVERTSTRING*);
+static BOOL w32_perform_reconversion (HWND, RECONVERTSTRING*);
+#endif
+
+#if defined (DOCUMENTFEED)
+#define DOCFEED_CSTR_LENG 64
+static LRESULT w32_get_ime_documentfeed_string (HWND, RECONVERTSTRING*);
+#endif
+
 #ifndef IDC_HAND
 #define IDC_HAND MAKEINTRESOURCE(32649)
 #endif
 
+#ifdef USE_W32_IME
+static int set_ime_font = 0;
+static LOGFONT ime_logfont = {0};
+static int IME_event_off_count;
+const char * const ImmGetConversionStatus_Name = "ImmGetConversionStatus";
+const char * const ImmSetConversionStatus_Name = "ImmSetConversionStatus";
+const char * const ImmNotifyIME_Name = "ImmNotifyIME";
+
+const char * const ImmCreateContext_Name = "ImmCreateContext";
+const char * const ImmDestroyContext_Name = "ImmDestroyContext";
+const char * const ImmAssociateContext_Name = "ImmAssociateContext";
+const char * const ImmGetHotKey_Name = "ImmGetHotKey";
+const char * const ImmGetProperty_Name = "ImmGetProperty";
+#ifdef IME_UNICODE
+const char * const ImmSetCompositionString_Name = "ImmSetCompositionStringW";
+const char * const ImmSetCompositionFont_Name = "ImmSetCompositionFontA"; /* LOGFONTA */
+const char * const ImmGetConversionList_Name = "ImmGetConversionListW";
+const char * const ImmConfigureIME_Name = "ImmConfigureIMEW";
+const char * const ImmGetCandidateList_Name = "ImmGetCandidateListW";
+const char * const ImmGetCandidateListCount_Name = "ImmGetCandidateListCountW";
+#else
+const char * const ImmSetCompositionString_Name = "ImmSetCompositionStringA";
+const char * const ImmSetCompositionFont_Name = "ImmSetCompositionFontA";
+const char * const ImmGetConversionList_Name = "ImmGetConversionListA";
+const char * const ImmConfigureIME_Name = "ImmConfigureIMEA";
+const char * const ImmGetCandidateList_Name = "ImmGetCandidateListA";
+const char * const ImmGetCandidateListCount_Name = "ImmGetCandidateListCountA";
+#endif
+#endif /* USE_W32_IME */
+
 /* Prefix for system colors.  */
 #define SYSTEM_COLOR_PREFIX "System"
 #define SYSTEM_COLOR_PREFIX_LEN (sizeof (SYSTEM_COLOR_PREFIX) - 1)
@@ -436,6 +502,17 @@ static void w32_set_icon_type (struct frame *, Lisp_Object, Lisp_Object);
 static void w32_set_icon_name (struct frame *, Lisp_Object, Lisp_Object);
 static void w32_explicitly_set_name (struct frame *, Lisp_Object, Lisp_Object);
 static void w32_set_title (struct frame *, Lisp_Object, Lisp_Object);
+#ifdef USE_W32_IME
+static void w32_set_ime_conv_window (HWND, struct frame *);
+static void w32_set_ime_status (HWND, int);
+static int w32_get_ime_status (HWND);
+static int w32_set_ime_mode (HWND, int, int);
+void w32_set_ime_logfont (HWND, struct frame *);
+static void w32_set_ime_font (HWND);
+static BOOL w32_get_ime_composition_string (HWND);
+static LRESULT CALLBACK conversion_agent_wndproc (HWND, UINT, WPARAM, LPARAM);
+static int initialize_conversion_agent (void);
+#endif /* USE_W32_IME */
 
 
 /* Store the screen positions of frame F into XPTR and YPTR.
@@ -4537,9 +4614,18 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 				  w32_get_key_modifiers (wParam, lParam));
 	  windows_translate = 1;
 	  break;
+	case VK_PROCESSKEY:  /* Generated by IME.  */
+#ifdef RECONVERSION
+	  if (!w32_get_ime_status (hwnd))
+	    {
+	      Fime_force_on (Qt);
+	      my_post_msg (&wmsg, hwnd, VK_PROCESSKEY, wParam, lParam);
+	      windows_translate = -1;
+	      break;
+	    }
+#endif	/* RECONVERSION */
 	case VK_CONTROL:
 	case VK_SHIFT:
-	case VK_PROCESSKEY:  /* Generated by IME.  */
 	  windows_translate = 1;
 	  break;
 	case VK_CANCEL:
@@ -4681,6 +4767,24 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 	  TranslateMessage (&windows_msg);
 	  goto dflt;
 	}
+#ifdef USE_W32_IME
+      else
+	{
+	  MSG ime_undo_test_msg;
+
+	  if (wParam == VK_BACK
+	      && ctrl_modifier == w32_get_key_modifiers (wParam, lParam)
+	      && w32_get_ime_status (hwnd) != 0
+	      && PeekMessage (&ime_undo_test_msg, hwnd, WM_KEYDOWN, WM_KEYDOWN,
+			      PM_NOYIELD | PM_NOREMOVE) != 0
+	      && ime_undo_test_msg.wParam == VK_BACK
+	      && ime_undo_test_msg.lParam == 0x40000001)
+	    {
+	      post_character_message (hwnd, msg, wParam, lParam, 0);
+	      break;
+	    }
+	}
+#endif /* USE_W32_IME */
       /* Fall through */
       FALLTHROUGH;
 
@@ -4700,6 +4804,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 				w32_get_key_modifiers (wParam, lParam));
       break;
 
+#ifndef USE_W32_IME
     case WM_UNICHAR:
       /* WM_UNICHAR looks promising from the docs, but the exact
 	 circumstances in which TranslateMessage sends it is one of those
@@ -4827,6 +4932,7 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
     case WM_IME_ENDCOMPOSITION:
       ignore_ime_char = 0;
       goto dflt;
+#endif /* !USE_W32_IME */
 
       /* Simulate middle mouse button events when left and right buttons
 	 are used together, but only if user has two button mouse. */
@@ -5692,7 +5798,84 @@ w32_wnd_proc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
       my_post_msg (&wmsg, hwnd, msg, wParam, lParam);
       return 1;
 
+#ifdef USE_W32_IME
+    case WM_IME_NOTIFY:
+      if (wParam == IMN_SETOPENSTATUS)
+	{
+	  if (w32_get_ime_status (hwnd))
+	    {
+	      struct frame *f = w32_window_to_frame (dpyinfo, hwnd);
+	      if (f)
+		{
+		  set_ime_font = 0;
+		  w32_set_ime_conv_window (hwnd, f);
+		}
+	    }
+	  if (!IME_event_off_count)
+	    my_post_msg (&wmsg, hwnd, WM_MULE_IME_STATUS, 0, 0);
+	  else
+	    IME_event_off_count--;
+	}
+      goto dflt;
+
+    case WM_IME_STARTCOMPOSITION:
+      {
+	struct frame *f = w32_window_to_frame (dpyinfo, hwnd);
+	if (f && !set_ime_font)
+	  {
+	    my_post_msg (&wmsg, hwnd, WM_MULE_IME_SET_FONT, (WPARAM) f, 0);
+	    set_ime_font = 1;
+	  }
+      }
+      goto dflt;
+
+    case WM_IME_SETCONTEXT:
+      set_ime_font = 0;
+      goto dflt;
+
+    case WM_IME_COMPOSITION:
+      if (lParam & GCS_RESULTSTR)
+        if (w32_get_ime_composition_string (hwnd))
+	  return 0;
+	else
+	  break;
+      goto dflt;
+
+#ifdef RECONVERSION
+    case WM_IME_REQUEST:
+      if (wParam == IMR_RECONVERTSTRING)
+	{
+	  if (!ime_enable_reconversion || !w32_get_ime_status (hwnd))
+	    return 0;
+	  if (lParam)
+	    return w32_get_ime_reconversion_string (hwnd,
+						    (RECONVERTSTRING*) lParam);
+	  else
+	    return sizeof (RECONVERTSTRING) + (RECONV_LENG * 2 + 1) * CHRSZ;
+	}
+#ifdef DOCUMENTFEED
+      else if (wParam == IMR_DOCUMENTFEED)
+	{
+	  if (!ime_enable_document_feed)
+	    return 0;
+	  if (lParam)
+	    return w32_get_ime_documentfeed_string (hwnd,
+						    (RECONVERTSTRING*) lParam);
+	  else
+	    return sizeof (RECONVERTSTRING) + (DOCFEED_LENG * 2 + DOCFEED_CSTR_LENG + 1) * CHRSZ;
+	}
+#endif
+      goto dflt;
+#endif
+#endif /* USE_W32_IME */
+
     default:
+
+#ifdef USE_W32_IME
+      if (MESSAGE_IMM_COM_P (msg))
+	return conversion_agent_wndproc (hwnd, msg, wParam, lParam);
+#endif /* USE_W32_IME */
+
       /* Check for messages registered at runtime. */
       if (msg == msh_mousewheel)
 	{
@@ -5973,6 +6156,10 @@ w32_default_font_parameter (struct frame *f, Lisp_Object parms)
     }
 
   gui_default_parameter (f, parms, Qfont, font, "font", "Font", RES_TYPE_STRING);
+#ifdef USE_W32_IME
+  gui_default_parameter (f, parms, Qime_font, Qnil,
+			 "ime-font", "IME-Font", RES_TYPE_STRING);
+#endif /* USE_W32_IME */
 }
 
 DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
@@ -8363,6 +8550,960 @@ DEFUN ("system-move-file-to-trash", Fsystem_move_file_to_trash,
 
 #endif /* WINDOWSNT */
 
+
+/***********************************************************************
+			  Input Method Editor
+ ***********************************************************************/
+#ifdef USE_W32_IME
+BOOL fIME = FALSE;
+
+typedef LONG (WINAPI *IMMSETCOMPOSITIONSTRINGPROC)
+  (HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);
+IMMSETCOMPOSITIONSTRINGPROC ImmSetCompositionStringProc;
+
+typedef BOOL (WINAPI *IMMSETCOMPOSITIONFONTPROC) (HIMC, LPLOGFONTA);
+IMMSETCOMPOSITIONFONTPROC ImmSetCompositionFontProc;
+
+typedef BOOL (WINAPI *IMMGETCONVERSIONSTATUSPROC)(HIMC, LPDWORD, LPDWORD);
+IMMGETCONVERSIONSTATUSPROC ImmGetConversionStatusProc;
+
+typedef BOOL (WINAPI *IMMSETCONVERSIONSTATUSPROC)(HIMC, DWORD, DWORD);
+IMMSETCONVERSIONSTATUSPROC ImmSetConversionStatusProc;
+
+typedef BOOL (WINAPI *IMMGETCONVERSIONLISTPROC)
+  (HKL, HIMC, LPCTSTR, LPCANDIDATELIST, DWORD, UINT);
+IMMGETCONVERSIONLISTPROC ImmGetConversionListProc;
+
+typedef BOOL (WINAPI *IMMCONFIGUREIMEPROC)(HKL, HWND, DWORD, LPVOID);
+IMMCONFIGUREIMEPROC ImmConfigureIMEProc;
+
+typedef BOOL (WINAPI *IMMNOTIFYIMEPROC)(HIMC, DWORD, DWORD, DWORD);
+IMMNOTIFYIMEPROC ImmNotifyIMEProc;
+
+typedef HIMC (WINAPI *IMMCREATECONTEXTPROC)(void);
+IMMCREATECONTEXTPROC ImmCreateContextProc;
+
+typedef BOOL (WINAPI *IMMDESTROYCONTEXTPROC)(HIMC);
+IMMDESTROYCONTEXTPROC ImmDestroyContextProc;
+
+typedef HIMC (WINAPI *IMMASSOCIATECONTEXTPROC) (HWND, HIMC);
+IMMASSOCIATECONTEXTPROC ImmAssociateContextProc;
+
+typedef BOOL (WINAPI *IMMGETCANDIDATELISTPROC)
+  (HIMC, DWORD, LPCANDIDATELIST, DWORD);
+IMMGETCANDIDATELISTPROC ImmGetCandidateListProc;
+
+typedef BOOL (WINAPI *IMMGETCANDIDATELISTCOUNTPROC) (HIMC, LPDWORD);
+IMMGETCANDIDATELISTCOUNTPROC ImmGetCandidateListCountProc;
+
+typedef BOOL (WINAPI *IMMGETHOTKEYPROC)(DWORD, LPUINT, LPUINT, LPHKL);
+IMMGETHOTKEYPROC ImmGetHotKeyProc;
+
+typedef BOOL (WINAPI *IMMGETPROPERTYPROC)(HKL, DWORD);
+IMMGETPROPERTYPROC ImmGetPropertyProc;
+
+// Lisp_Object Vime_control;
+
+static void
+w32_set_ime_conv_window (HWND hwnd, struct frame *f)
+{
+  if (fIME && !NILP (Vime_control))
+    {
+      HIMC himc;
+      COMPOSITIONFORM compform;
+      struct window *w = XWINDOW (FRAME_SELECTED_WINDOW (f));
+
+      /* If Vw32_ime_composition_window is set, try it. */
+      if (!NILP (Vw32_ime_composition_window)
+	  && WINDOWP (Vw32_ime_composition_window)
+	  && (WINDOW_FRAME (XWINDOW (Vw32_ime_composition_window))
+	      == WINDOW_FRAME (w)))
+	w = XWINDOW (Vw32_ime_composition_window);
+
+      himc = get_ime_context_fn (hwnd);
+      compform.dwStyle = CFS_RECT;
+
+      compform.ptCurrentPos.x =	WINDOW_TEXT_TO_FRAME_PIXEL_X (w, w->phys_cursor.x);
+
+      compform.ptCurrentPos.y = WINDOW_TO_FRAME_PIXEL_Y (w, w->phys_cursor.y);
+#if 0
+      if (FRAME_FONT (f)->vertical_centering == 1)
+	compform.ptCurrentPos.y += FRAME_FONT (f)->baseline_offset;
+#endif
+
+      compform.rcArea.left = (WINDOW_BOX_LEFT_EDGE_X (w)
+			      + WINDOW_LEFT_MARGIN_WIDTH (w)
+			      + WINDOW_LEFT_FRINGE_WIDTH (w));
+
+      compform.rcArea.top = (WINDOW_TOP_EDGE_Y (w)
+			     + WINDOW_HEADER_LINE_HEIGHT (w));
+
+      compform.rcArea.right = (WINDOW_BOX_RIGHT_EDGE_X (w)
+			       - WINDOW_RIGHT_MARGIN_WIDTH (w)
+			       - WINDOW_RIGHT_FRINGE_WIDTH (w)) + 1;
+
+      compform.rcArea.bottom = (WINDOW_BOTTOM_EDGE_Y (w)
+				- WINDOW_MODE_LINE_HEIGHT (w));
+
+      set_ime_composition_window_fn (himc, &compform);
+      release_ime_context_fn (hwnd, himc);
+    }
+}
+
+static void
+w32_set_ime_status (HWND hwnd, int openp)
+{
+  HIMC himc;
+
+  himc = get_ime_context_fn (hwnd);
+  set_ime_open_status_fn (himc, openp);
+  release_ime_context_fn (hwnd, himc);
+}
+
+static int
+w32_get_ime_status (HWND hwnd)
+{
+  HIMC himc;
+  int ret;
+
+  himc = get_ime_context_fn (hwnd);
+  ret = get_ime_open_status_fn (himc);
+  release_ime_context_fn (hwnd, himc);
+
+  return ret;
+}
+
+static int
+w32_set_ime_mode (HWND hwnd, int mode, int mask)
+{
+  HIMC himc;
+  DWORD cmode, smode;
+
+  himc = get_ime_context_fn (hwnd);
+  if (!(ImmGetConversionStatusProc) (himc, &cmode, &smode))
+    return 0;
+
+  cmode = (cmode & (~mask)) | (mode & mask);
+
+  (ImmSetConversionStatusProc) (himc, cmode, smode);
+  release_ime_context_fn (hwnd, himc);
+
+  return 1;
+}
+
+static BOOL
+w32_get_ime_composition_string (HWND hwnd)
+{
+  HIMC hIMC;
+  int size;
+  HANDLE himestr;
+#ifdef IME_UNICODE
+  LPWSTR lpstr;
+#else
+  LPSTR lpstr;
+#endif
+
+  struct frame *f;
+
+  hIMC = get_ime_context_fn (hwnd);
+  if (!hIMC)
+    return FALSE;
+
+  size = get_composition_string_fn (hIMC, GCS_RESULTSTR, NULL, 0);
+#ifdef IME_UNICODE
+  size += sizeof (WCHAR);
+#else
+  size += sizeof (CHAR);
+#endif
+  himestr = HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, size);
+  if (!himestr)
+    abort ();
+
+  get_composition_string_fn (hIMC, GCS_RESULTSTR, himestr, size);
+  release_ime_context_fn (hwnd, hIMC);
+  {
+    W32Msg wmsg;
+    f = SELECTED_FRAME ();
+    my_post_msg (&wmsg, hwnd, WM_MULE_IME_REPORT,
+		 (WPARAM) himestr, (LPARAM) f);
+  }
+  return TRUE;
+}
+
+#ifdef RECONVERSION
+static EMACS_INT compstr_beginning_pos(int max_char)
+{
+  EMACS_INT bol, point = PT, pt;
+  for (bol = XFIXNAT(Fline_beginning_position(Qnil)), pt = PT;
+       PT >= bol && PT > point - max_char; ) {
+    pt = PT;
+    if (NILP(Fforward_word (make_fixnum (-1))))
+      break;
+  }
+  Fgoto_char (make_fixnum(point));
+  return pt;
+}
+
+static EMACS_INT compstr_end_pos(int max_char)
+{
+  EMACS_INT eol, point = PT, pt;
+
+  for (eol = XFIXNAT(Fline_end_position(Qnil)), pt = PT;
+       PT <= eol && PT < point + max_char;) {
+    pt = PT;
+    if (NILP(Fforward_word (make_fixnum (1))))
+      break;
+  }
+  Fgoto_char (make_fixnum(point));
+  return pt;
+}
+
+static LRESULT
+get_reconversion_string (HWND hwnd,
+			 RECONVERTSTRING *reconv,
+			 unsigned short *compstr)
+{
+  EMACS_INT pt, pt_byte, start, end, len, t_start, t_end, compstr_len;
+  W32Msg wmsg;
+
+  if (!NILP (BVAR (current_buffer, read_only)))
+    return 0;
+
+  pt = PT;
+  pt_byte = PT_BYTE;
+
+  if (compstr)
+    {
+      t_start = PT;
+      start = compstr_beginning_pos (DOCFEED_LENG);
+      end = compstr_end_pos (DOCFEED_LENG);
+    }
+  else if (!NILP (BVAR (current_buffer, mark_active))
+    && !NILP (Vtransient_mark_mode))
+    {
+      if (marker_position (BVAR (current_buffer, mark)) < PT)
+	{
+	  t_start = marker_position (BVAR (current_buffer, mark));
+	  t_end = PT;
+	}
+      else
+	{
+	  t_start = PT;
+	  t_end = marker_position (BVAR (current_buffer, mark));
+	}
+      Fgoto_char (make_fixnum (t_end));
+      while (!NILP (Fbolp ()) && t_start < PT)
+	Fforward_char (make_fixnum (-1));
+      if (t_start >= PT)
+	return 0;
+      t_end = PT;
+    }
+  else
+    {
+      if (NILP (Feobp ()))
+	Fforward_char (make_fixnum (1));
+      if (!NILP (Fforward_word (make_fixnum (-1))))
+	t_start = PT;
+      else
+	{
+	  SET_PT_BOTH (pt, pt_byte);
+	  return 0;
+	}
+      Fforward_word (make_fixnum (1));
+      t_end = PT;
+      SET_PT_BOTH (pt, pt_byte);
+      if (t_end < PT)
+	return 0;
+    }
+
+  if (!compstr)
+    {
+      if (t_start == t_end)
+	return 0;
+
+      Fgoto_char (make_fixnum (t_start));
+      start = compstr_beginning_pos (RECONV_LENG);
+      Fgoto_char (make_fixnum (t_end));
+      end = compstr_end_pos (RECONV_LENG);
+    }
+
+  len = end - start;
+  if (reconv)
+    {
+      int pos;
+      WCHAR *s;
+
+      s = (WCHAR *) (reconv + 1);
+
+      for (pos = start; pos < t_start; pos++)
+	*s++ = (WCHAR) FETCH_CHAR (CHAR_TO_BYTE (pos));
+
+      if (compstr)
+	{
+	  for (compstr_len = 0; compstr[compstr_len]; compstr_len++)
+	    *s++ = compstr[compstr_len];
+
+	  len += compstr_len;
+	}
+      else
+	compstr_len = t_end - t_start;
+
+      for (; pos < end; pos++)
+	*s++ = (WCHAR) FETCH_CHAR (CHAR_TO_BYTE (pos));
+
+      *s = 0;
+    }
+  else
+    {
+      SET_PT_BOTH (pt, pt_byte);
+      if (compstr)
+	{
+	  for (compstr_len = 0; compstr[compstr_len]; compstr_len++)
+	    ;
+
+	  len += compstr_len;
+	}
+      return (sizeof (RECONVERTSTRING) + (len + 1) * CHRSZ);
+    }
+
+  reconv->dwStrOffset = sizeof (RECONVERTSTRING);
+  reconv->dwStrLen = len;
+  reconv->dwCompStrOffset =
+    reconv->dwTargetStrOffset = (t_start - start) * CHRSZ;
+  reconv->dwCompStrLen =
+    reconv->dwTargetStrLen = compstr_len;
+
+  if (!compstr)
+    my_post_msg (&wmsg, hwnd, WM_MULE_IME_DEL_RANGE, (WPARAM) t_start, (LPARAM) t_end);
+
+  return (reconv->dwSize = sizeof (RECONVERTSTRING) + (len + 1) * CHRSZ);
+}
+
+static LRESULT
+w32_get_ime_reconversion_string (HWND hwnd,
+				 RECONVERTSTRING *reconv)
+{
+  return get_reconversion_string (hwnd, reconv, NULL);
+}
+#endif /* RECONVERSION */
+
+#if defined(DOCUMENTFEED)
+static LRESULT
+w32_get_ime_documentfeed_string (HWND hwnd,
+				 RECONVERTSTRING *reconv)
+{
+  unsigned short ime_compstr[DOCFEED_CSTR_LENG];
+  HIMC hIMC;
+  LONG l;
+
+  if (hIMC = get_ime_context_fn (hwnd))
+    {
+      if (get_composition_string_fn (hIMC, GCS_COMPSTR, NULL, 0)
+	  >= DOCFEED_CSTR_LENG * CHRSZ)
+	{
+	  release_ime_context_fn (hwnd, hIMC);
+	  return 0;
+	}
+
+      switch (l = get_composition_string_fn
+	      (hIMC, GCS_COMPSTR, ime_compstr,
+	       (DOCFEED_CSTR_LENG - 1) * CHRSZ))
+	{
+	  case IMM_ERROR_NODATA:
+	  case IMM_ERROR_GENERAL:
+	    ime_compstr[0] = 0;
+	    break;
+	  default:
+	    ime_compstr[l / CHRSZ] = 0;
+	    break;
+	}
+      release_ime_context_fn (hwnd, hIMC);
+
+      return get_reconversion_string (hwnd, reconv, ime_compstr);
+    }
+
+  return 0;
+}
+#endif /* DOCUMENTFEED */
+
+void
+w32_ime_control_init (void)
+{
+  HMODULE hImm32;
+  HMODULE hUser32;
+
+  hImm32 = GetModuleHandle ("IMM32.DLL");
+  if (!hImm32)
+    hImm32 = LoadLibrary ("IMM32.DLL");
+
+  fIME = FALSE;
+  Vime_control = Qnil;
+  IME_event_off_count = 0;
+
+  if (hImm32)
+    {
+      ImmGetConversionStatusProc =
+	(IMMGETCONVERSIONSTATUSPROC)
+	GetProcAddress (hImm32,
+			ImmGetConversionStatus_Name);
+      ImmSetConversionStatusProc =
+	(IMMSETCONVERSIONSTATUSPROC)
+	GetProcAddress (hImm32,
+			ImmSetConversionStatus_Name);
+      ImmNotifyIMEProc =
+	(IMMNOTIFYIMEPROC)
+	GetProcAddress (hImm32,
+			ImmNotifyIME_Name);
+      ImmCreateContextProc =
+	(IMMCREATECONTEXTPROC)
+	GetProcAddress (hImm32,
+			ImmCreateContext_Name);
+      ImmDestroyContextProc =
+	(IMMDESTROYCONTEXTPROC)
+	GetProcAddress (hImm32,
+			ImmDestroyContext_Name);
+      ImmAssociateContextProc =
+	(IMMASSOCIATECONTEXTPROC)
+	GetProcAddress (hImm32,
+			ImmAssociateContext_Name);
+      ImmGetHotKeyProc =
+	(IMMGETHOTKEYPROC)
+	GetProcAddress (hImm32,
+			ImmGetHotKey_Name);
+      ImmGetPropertyProc =
+	(IMMGETPROPERTYPROC)
+	GetProcAddress (hImm32,	ImmGetProperty_Name);
+      ImmSetCompositionStringProc =
+	(IMMSETCOMPOSITIONSTRINGPROC)
+	GetProcAddress (hImm32, ImmSetCompositionString_Name);
+      ImmSetCompositionFontProc =
+	(IMMSETCOMPOSITIONFONTPROC)
+	GetProcAddress (hImm32, ImmSetCompositionFont_Name);
+      ImmGetConversionListProc =
+	(IMMGETCONVERSIONLISTPROC)
+	GetProcAddress (hImm32,
+			ImmGetConversionList_Name);
+      ImmConfigureIMEProc =
+	(IMMCONFIGUREIMEPROC)
+	GetProcAddress (hImm32,
+			ImmConfigureIME_Name);
+      ImmGetCandidateListProc =
+	(IMMGETCANDIDATELISTPROC)
+	GetProcAddress (hImm32,
+			ImmGetCandidateList_Name);
+      ImmGetCandidateListCountProc =
+	(IMMGETCANDIDATELISTCOUNTPROC)
+	GetProcAddress (hImm32,
+			ImmGetCandidateListCount_Name);
+
+      if (ImmSetCompositionStringProc &&
+	  ImmSetCompositionFontProc &&
+	  ImmGetPropertyProc &&
+	  ImmGetConversionStatusProc &&
+	  ImmSetConversionStatusProc &&
+	  ImmGetConversionListProc &&
+	  ImmConfigureIMEProc &&
+	  ImmNotifyIMEProc &&
+	  ImmCreateContextProc &&
+	  ImmDestroyContextProc &&
+	  ImmAssociateContextProc &&
+	  ImmGetCandidateListProc &&
+	  ImmGetCandidateListCountProc &&
+	  ImmGetHotKeyProc)
+	{
+	  fIME = TRUE;
+	  Vime_control = Qt;
+	}
+    }
+}
+
+#ifdef HAVE_NTGUI
+EXFUN (Ffont_at, 3);
+static int
+need_set_ime_font (PLOGFONT p)
+{
+  if (!p ||
+      (p->lfHeight            == ime_logfont.lfHeight
+       && p->lfWidth          == ime_logfont.lfWidth
+       && p->lfEscapement     == ime_logfont.lfEscapement
+       && p->lfOrientation    == ime_logfont.lfOrientation
+       && p->lfWeight         == ime_logfont.lfWeight
+       && p->lfItalic         == ime_logfont.lfItalic
+       && p->lfUnderline      == ime_logfont.lfUnderline
+       && p->lfStrikeOut      == ime_logfont.lfStrikeOut
+       && p->lfCharSet        == ime_logfont.lfCharSet
+       && p->lfOutPrecision   == ime_logfont.lfOutPrecision
+       && p->lfClipPrecision  == ime_logfont.lfClipPrecision
+       && p->lfQuality        == ime_logfont.lfQuality
+       && p->lfPitchAndFamily == ime_logfont.lfPitchAndFamily
+       && strncmp (p->lfFaceName, ime_logfont.lfFaceName, LF_FACESIZE) == 0))
+    return 0;
+  else
+    return 1;
+}
+
+void
+w32_set_ime_logfont (HWND hwnd, struct frame *f)
+{
+  Lisp_Object ime_font = Qnil, temp = Qnil, font = Qnil, family;
+  int fsid = -1;
+  LOGFONT logfont = {0};
+
+  if (!IsWindow (hwnd))
+    return;
+
+  if (!fIME || NILP(Vime_control))
+    return;
+
+  if (STRINGP(ime_font = get_frame_param (f, Qime_font))
+          /* fontset */
+      && ((fsid = fs_query_fontset(ime_font, 0)) >= 0
+	  && !NILP(font = fontset_ascii(fsid))
+	  && !NILP(font = font_spec_from_name(font))
+	  && !NILP(temp = Ffontset_font(temp, make_fixnum(0x3042), Qnil))
+	  && !NILP(family = XCAR(temp))
+	  /* font */
+	  || !NILP(font = font_spec_from_name(ime_font))
+	  && SYMBOLP(family = AREF (font, FONT_FAMILY_INDEX))
+	  && STRINGP(family = SYMBOL_NAME(family)))
+
+      /* use font object */
+	  /* frame-parameter */
+      || (FONTP(font = ime_font)
+	  /* frame fontset */
+	  || ((fsid = FRAME_FONTSET(f)) >= 0
+	      && !NILP(font =
+		   Ffont_at(make_fixnum(0), Qnil,
+			    temp = Fchar_to_string(make_fixnum(0x3042))))))
+      && SYMBOLP(family = Ffont_get(font, QCfamily))
+      && STRINGP(family = SYMBOL_NAME(family))
+      && !NILP(font = copy_font_spec(font))) {
+    Lisp_Object tail;
+
+    fill_in_logfont (f, &logfont, font);
+
+    logfont.lfWidth = 0;
+
+    family = ENCODE_SYSTEM(family);
+
+    strcpy(logfont.lfFaceName, SDATA(family));
+
+    /* rescale */
+    for (tail = Vface_font_rescale_alist; CONSP (tail); tail = XCDR (tail)) {
+      temp = XCAR (tail);
+      if (!FLOATP (XCDR (temp)))
+	continue;
+
+      if (STRINGP (XCAR (temp))) {
+	if (fast_string_match_ignore_case (XCAR (temp), family) >= 0) {
+	  logfont.lfHeight *=  XFLOAT_DATA (XCDR (temp));
+	  break;
+	}
+      } else if (FONT_SPEC_P (XCAR (temp))) {
+	Lisp_Object name;
+	if (!NILP(name = Ffont_get(XCAR (temp), QCfamily)) &&
+	    STRINGP(name) &&
+	    xstrcasecmp(SDATA(name), SDATA(family)) == 0) {
+	  logfont.lfHeight *=  XFLOAT_DATA (XCDR (temp));
+	  break;
+	}
+      }
+    }
+  } else {
+    HFONT hfont = FONT_HANDLE (FRAME_FONT (f));
+    GetObject (hfont, sizeof (logfont), &logfont);
+  }
+
+  if (need_set_ime_font (&logfont))
+    {
+      ime_logfont = logfont;
+      PostMessage (hwnd, WM_MULE_IMM_SET_IMEFONT, (WPARAM) f, 0);
+    }
+}
+
+static void
+w32_set_ime_font (HWND hwnd)
+{
+  HIMC himc;
+
+  if (!fIME || NILP (Vime_control))
+    return;
+
+  himc = get_ime_context_fn (hwnd);
+  if (!himc)
+    return;
+  (ImmSetCompositionFontProc) (himc, &ime_logfont);
+  release_ime_context_fn (hwnd, himc);
+}
+#endif  /* HAVE_NTGUI */
+
+static LRESULT CALLBACK
+conversion_agent_wndproc (HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
+{
+  HIMC himc, holdimc;
+
+  switch (message)
+    {
+    case WM_MULE_IMM_SET_STATUS:
+      if (InSendMessage())
+	ReplyMessage(1);
+      w32_set_ime_status (hwnd, (int) wparam);
+      break;
+
+    case WM_MULE_IMM_GET_STATUS:
+      return w32_get_ime_status (hwnd);
+
+    case WM_MULE_IMM_SET_MODE:
+      return w32_set_ime_mode (hwnd, (int) wparam, (int) lparam);
+
+    case WM_MULE_IMM_SET_IMEFONT:
+      w32_set_ime_font (hwnd);
+    case WM_MULE_IMM_SET_CONVERSION_WINDOW:
+      if (w32_get_ime_status (hwnd))
+	w32_set_ime_conv_window (hwnd, (struct frame *) wparam);
+      break;
+
+#ifdef RECONVERSION
+    case WM_MULE_IMM_PERFORM_RECONVERSION:
+      if (ime_enable_reconversion)
+	w32_perform_reconversion(hwnd, (RECONVERTSTRING*)lparam);
+      break;
+#endif
+
+#if 0
+    case WM_MULE_IMM_GET_COMPOSITION_STRING:
+      return w32_get_ime_composition_string (hwnd);
+#endif
+
+    default:
+      return DefWindowProc (hwnd, message, wparam, lparam);
+    }
+  return 0;
+}
+
+
+/*
+  Emacs Lisp function entries
+*/
+
+extern Lisp_Object VIME_command_off_flag;
+
+DEFUN ("ime-force-on", Fime_force_on, Sime_force_on, 0, 1, 0,
+       doc: /* Force status of IME open.  */)
+  (Lisp_Object eventp)
+{
+  if (fIME && !NILP (Vime_control))
+    {
+      HIMC himc;
+      HWND hwnd;
+
+      if (!NILP (Fw32_get_ime_open_status ()))
+	return Qnil;
+#ifdef HAVE_NTGUI
+      if (NILP (eventp))
+	IME_event_off_count++;
+      hwnd = FRAME_W32_WINDOW (SELECTED_FRAME ());
+#else
+      hwnd = hwndConsole;
+#endif
+      SendMessage (hwnd, WM_MULE_IMM_SET_STATUS, 1, 0);
+    }
+  return Qnil;
+}
+
+DEFUN ("ime-force-off", Fime_force_off, Sime_force_off, 0, 1, 0,
+       doc: /* Force status of IME close.  */)
+  (Lisp_Object eventp)
+{
+  if (fIME && !NILP (Vime_control))
+    {
+      HIMC himc;
+      HWND hwnd;
+
+      if (NILP (Fw32_get_ime_open_status ()))
+	return Qnil;
+#ifdef HAVE_NTGUI
+      if (NILP (eventp))
+	IME_event_off_count++;
+      hwnd = FRAME_W32_WINDOW (SELECTED_FRAME ());
+#else
+      hwnd = hwndConsole;
+#endif
+      SendMessage (hwnd, WM_MULE_IMM_SET_STATUS, 0, 0);
+    }
+  return Qnil;
+}
+
+DEFUN ("w32-set-ime-mode",
+       Fw32_set_ime_mode,
+       Sw32_set_ime_mode, 1, 2, 0,
+       doc: /* Set IME mode to MODE. If FRAME is omitted, the selected frame is used.  */)
+  (Lisp_Object mode, Lisp_Object frame)
+{
+  struct frame *f;
+
+  if (NILP (frame))
+    {
+      f = SELECTED_FRAME ();
+    }
+  else
+    {
+      CHECK_FRAME (frame);
+      f = XFRAME (frame);
+    }
+  if (fIME && !NILP (Vime_control))
+    {
+      HWND hwnd;
+      int ret;
+      int newmode, mask;
+
+      newmode = 0;
+      mask = 0;
+
+      hwnd = FRAME_W32_WINDOW (f);
+
+      if (EQ (mode, intern ("katakana")))
+	{
+	  newmode |= IME_CMODE_KATAKANA;
+	  mask |= IME_CMODE_KATAKANA;
+	}
+      else if (EQ (mode, intern ("hiragana")))
+	{
+	  newmode &= ~IME_CMODE_KATAKANA;
+	  mask |= IME_CMODE_KATAKANA;
+	}
+      else if (EQ (mode, intern ("kanji")))
+	{
+	  newmode |= IME_CMODE_HANJACONVERT;
+	  mask |= IME_CMODE_HANJACONVERT;
+	}
+      else if (EQ (mode, intern ("nokanji")))
+	{
+	  newmode &= ~IME_CMODE_HANJACONVERT;
+	  mask |= IME_CMODE_HANJACONVERT;
+	}
+      else if (EQ (mode, intern ("code")))
+	{
+	  newmode |= IME_CMODE_CHARCODE;
+	  mask |= IME_CMODE_CHARCODE;
+	}
+      else if (EQ (mode, intern ("nocode")))
+	{
+	  newmode &= ~IME_CMODE_CHARCODE;
+	  mask |= IME_CMODE_CHARCODE;
+	}
+      else if (EQ (mode, intern ("non-convert")))
+	{
+	  newmode |= IME_CMODE_NOCONVERSION;
+	  mask |= IME_CMODE_NOCONVERSION;
+	}
+      else if (EQ (mode, intern ("convert")))
+	{
+	  newmode &= ~IME_CMODE_NOCONVERSION;
+	  mask |= IME_CMODE_NOCONVERSION;
+	}
+      else
+	error ("unknown mode!!");
+
+      ret = SendMessage (hwnd, WM_MULE_IMM_SET_MODE,
+			 (WPARAM) newmode, (LPARAM) mask);
+
+      if (!ret)
+	return Qnil;
+
+      return Qt;
+    }
+  return Qnil;
+}
+
+DEFUN ("w32-ime-register-word-dialog",
+       Fw32_ime_register_word_dialog,
+       Sw32_ime_register_word_dialog, 2, 2, 0,
+       doc: /* Open IME regist word dialog.  */)
+  (Lisp_Object reading, Lisp_Object word)
+{
+  HKL hkl;
+  int reading_len, word_len;
+  REGISTERWORD regword;
+  Lisp_Object encoded_reading, encoded_word;
+
+  CHECK_STRING (reading);
+  CHECK_STRING (word);
+
+  if (fIME && !NILP (Vime_control) && ImmConfigureIMEProc)
+    {
+      hkl = GetKeyboardLayout (0);
+      encoded_reading = Fencode_coding_string (reading,
+					       Vlocale_coding_system,
+					       Qnil, Qnil);
+      reading_len = SBYTES (encoded_reading);
+      regword.lpReading = SDATA (encoded_reading);
+
+      encoded_word = Fencode_coding_string (word,
+					    Vlocale_coding_system,
+					    Qnil, Qnil);
+      word_len = SBYTES (encoded_word);
+      regword.lpWord = SDATA (encoded_word);
+      (ImmConfigureIMEProc) (hkl, FRAME_W32_WINDOW (SELECTED_FRAME ()),
+			    IME_CONFIG_REGISTERWORD, &regword);
+    }
+  return Qnil;
+}
+
+DEFUN ("ime-get-property", Fime_get_property, Sime_get_property, 1, 1, 0,
+       doc: /* Retrieves the property and capabilities of the IME associated with the specified input locale.
+INDEX is one of igp-property, igp-conversion, igp-sentence, igp-ui, igp-setcompstr, igp-select of igp-getimeversion*/)
+  (Lisp_Object index)
+{
+  int i;
+  Lisp_Object val;
+  DWORD v;
+
+  static const struct {
+    const char *name;
+    DWORD index;
+  } index_map[] = {
+    {"property", IGP_PROPERTY},
+    {"conversion", IGP_CONVERSION},
+    {"sentence", IGP_SENTENCE},
+    {"ui", IGP_UI},
+    {"setcompstr", IGP_SETCOMPSTR},
+    {"select", IGP_SELECT},
+    {"getimeversion", IGP_GETIMEVERSION},
+  }, prop_map[] = {
+    {"at-caret", IME_PROP_AT_CARET},
+    {"special-ui", IME_PROP_SPECIAL_UI},
+    {"candlist-start-from-1", IME_PROP_CANDLIST_START_FROM_1},
+    {"unicode", IME_PROP_UNICODE},
+    {"complete-on-unselect", IME_PROP_COMPLETE_ON_UNSELECT},
+  }, ui_map[] = {
+    {"rot2700", UI_CAP_2700},
+    {"rot90", UI_CAP_ROT90},
+    {"rotany", UI_CAP_ROTANY},
+  }, setcompstr_map[] = {
+    {"compstr", SCS_CAP_COMPSTR},
+    {"makeread", SCS_CAP_MAKEREAD},
+    {"setreconvertstring", SCS_CAP_SETRECONVERTSTRING},
+  }, select_map[] = {
+    {"conversion", SELECT_CAP_CONVERSION},
+    {"sentence", SELECT_CAP_SENTENCE},
+  }, imeversion_map[] = {
+    {"ver-0310", IMEVER_0310},
+    {"ver-0400", IMEVER_0400},
+  };
+
+  CHECK_SYMBOL(index);
+  for (i = 0; i < sizeof(index_map) / sizeof(index_map[0]); i++)
+    if (EQ(index, intern(index_map[i].name)))
+      break;
+  if (i >=  sizeof(index_map) / sizeof(index_map[0]))
+    return Qnil;
+
+  v = (*ImmGetPropertyProc)(GetKeyboardLayout(0), index_map[i].index);
+  val = Qnil;
+#define MAKE_CAP_LIST(map) do { \
+  int j; \
+  for (j = sizeof(map) / sizeof(map[0]) - 1; j >= 0 ; j--) \
+      if (v & map[j].index) \
+	val = Fcons(intern(map[j].name), val); \
+} while(0)
+
+  switch (index_map[i].index) {
+  case IGP_PROPERTY:
+    MAKE_CAP_LIST(prop_map);
+    break;
+  case IGP_UI:
+    MAKE_CAP_LIST(ui_map);
+    break;
+  case IGP_SETCOMPSTR:
+    MAKE_CAP_LIST(setcompstr_map);
+    break;
+  case IGP_SELECT:
+    MAKE_CAP_LIST(select_map);
+    break;
+  case IGP_GETIMEVERSION:
+    MAKE_CAP_LIST(imeversion_map);
+    break;
+  }
+  return val;
+}
+
+#ifdef RECONVERSION
+BOOL w32_perform_reconversion(HWND hwnd, RECONVERTSTRING *reconv)
+{
+  struct frame *f = SELECTED_FRAME ();
+  HIMC himc;
+  BOOL result = FALSE;
+
+  himc = get_ime_context_fn (hwnd);
+  if (!himc) {
+    xfree(reconv);
+    return FALSE;
+  }
+
+  if ((*ImmSetCompositionStringProc) (himc,
+				      SCS_QUERYRECONVERTSTRING,
+				      reconv, reconv->dwSize,
+				      NULL, 0 )
+      && (*ImmSetCompositionStringProc) (himc,
+					 SCS_SETRECONVERTSTRING,
+					 reconv, reconv->dwSize,
+					 NULL, 0)) {
+    /* Set the position of candidate list dialog. */
+    release_ime_context_fn (hwnd, himc);
+    w32_set_ime_conv_window (hwnd, f);
+    result = TRUE;
+  } else
+    release_ime_context_fn (hwnd, himc);
+  xfree(reconv);
+  return result;
+}
+
+DEFUN ("w32-ime-perform-reconversion",
+       Fw32_ime_perform_reconversion,
+       Sw32_ime_perform_reconversion, 0, 0, "",
+       doc: /* perfom ime reconversion.  */)
+  (void)
+{
+  HWND hwnd = FRAME_W32_WINDOW(SELECTED_FRAME());
+  DWORD size;
+  RECONVERTSTRING *reconv;
+
+  if (!ime_enable_reconversion ||
+      NILP(Fw32_get_ime_open_status ()))
+    return Qnil;
+
+  if ((size = get_reconversion_string (hwnd, NULL, NULL))
+      && (reconv = xmalloc (size)) != NULL
+      && (memset (reconv, 0, size), (reconv->dwSize = size))
+      && get_reconversion_string (hwnd, reconv, NULL))
+    PostMessage(hwnd, WM_MULE_IMM_PERFORM_RECONVERSION, 0, (LPARAM) reconv);
+
+  return Qt;
+}
+#endif
+
+#undef W32_IME_DEBUG
+
+#ifdef W32_IME_DEBUG
+DEFUN ("print-stderr", Fprint_stderr, Sprint_stderr, 1, 1, 0,
+       doc: /* Output a string to stderr. */)
+  (Lisp_Object str)
+{
+  if (STRINGP (str))
+    {
+      struct Lisp_String *s = XSTRING (str);
+      fprintf (stderr, "%s\n", s->data);
+    }
+  else
+    fprintf (stderr, "nil\n");
+  fflush (stderr);
+
+  return Qt;
+}
+#endif
+
+#endif /* USE_W32_IME */
 
 /***********************************************************************
 			 w32 specialized functions
@@ -10730,6 +11871,9 @@ frame_parm_handler w32_frame_parm_handlers[] =
   gui_set_fullscreen,
   gui_set_font_backend,
   gui_set_alpha,
+#ifdef USE_W32_IME
+  0, /* ime-font */
+#endif /* USE_W32_IME */
   0, /* x_set_sticky */
   w32_set_tool_bar_position,
   w32_set_inhibit_double_buffering,
@@ -10755,6 +11899,10 @@ syms_of_w32fns (void)
   PDUMPER_IGNORE (w32_visible_system_caret_hwnd);
 
   DEFSYM (Qundefined_color, "undefined-color");
+#ifdef USE_W32_IME
+  DEFSYM (Qw32_ime_buffer_switch_p, "w32-ime-buffer-switch-p");
+  DEFSYM (Qime_font, "ime-font");
+#endif /* USE_W32_IME */
   DEFSYM (Qcancel_timer, "cancel-timer");
   DEFSYM (Qhyper, "hyper");
   DEFSYM (Qsuper, "super");
@@ -11087,6 +12235,27 @@ The default value of this variable is therefore t, to ignore modifier
 keys when IME input is received.  */);
   w32_ignore_modifiers_on_IME_input = true;
 
+#ifdef USE_W32_IME
+#ifdef RECONVERSION
+  DEFVAR_BOOL ("ime-enable-reconversion", ime_enable_reconversion,
+	       doc: /* Non-nil enables IME reconversion capability.  */);
+  ime_enable_reconversion = 1;
+#endif
+#ifdef DOCUMENTFEED
+  DEFVAR_BOOL ("ime-enable-document-feed", ime_enable_document_feed,
+	       doc: /* Non-nil enables IME document feed capability.  */);
+  ime_enable_document_feed = 1;
+#endif
+  DEFVAR_LISP ("ime-control", Vime_control, doc: /* IME control flag.  */);
+  Vime_control = Qnil;
+
+  DEFVAR_LISP ("w32-ime-composition-window",
+	       Vw32_ime_composition_window,
+	       doc: /* If this is a window of current frame, IME composition window appears on the
+window instead of current window.  */);
+  Vw32_ime_composition_window = Qnil;
+#endif /* USE_W32_IME */
+
 #if 0 /* TODO: Port to W32 */
   defsubr (&Sx_change_window_property);
   defsubr (&Sx_delete_window_property);
@@ -11141,6 +12310,20 @@ keys when IME input is received.  */);
   defsubr (&Sw32_get_ime_open_status);
   defsubr (&Sw32_set_ime_open_status);
 
+#ifdef USE_W32_IME
+  defsubr (&Sw32_set_ime_mode);
+  defsubr (&Sw32_ime_register_word_dialog);
+  defsubr (&Sime_force_on);
+  defsubr (&Sime_force_off);
+  defsubr (&Sime_get_property);
+#ifdef RECONVERSION
+  defsubr (&Sw32_ime_perform_reconversion);
+#endif
+#ifdef W32_IME_DEBUG
+  defsubr (&Sprint_stderr);
+#endif
+#endif /* USE_W32_IME */
+
 #ifdef WINDOWSNT
   defsubr (&Sw32_read_registry);
   defsubr (&Sfile_system_info);
diff --git a/src/w32font.c b/src/w32font.c
index ccbd3837afb..d901ab468ce 100644
--- a/src/w32font.c
+++ b/src/w32font.c
@@ -55,7 +55,10 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #define JOHAB_CHARSET 130
 #endif
 
-static void fill_in_logfont (struct frame *, LOGFONT *, Lisp_Object);
+#ifndef USE_W32_IME
+static
+#endif /* !USE_W32_IME */
+void fill_in_logfont (struct frame *, LOGFONT *, Lisp_Object);
 
 static BYTE w32_antialias_type (Lisp_Object);
 static Lisp_Object lispy_antialias_type (BYTE);
@@ -2027,7 +2030,10 @@ w32_to_fc_weight (int n)
 }
 
 /* Fill in all the available details of LOGFONT from FONT_SPEC.  */
-static void
+#ifndef USE_W32_IME
+static
+#endif /* !USE_W32_IME */
+void
 fill_in_logfont (struct frame *f, LOGFONT *logfont, Lisp_Object font_spec)
 {
   Lisp_Object tmp, extra;
diff --git a/src/w32font.h b/src/w32font.h
index 3f780c1d866..724d158a69d 100644
--- a/src/w32font.h
+++ b/src/w32font.h
@@ -83,6 +83,9 @@ int w32font_draw (struct glyph_string *s, int from, int to,
 int uniscribe_check_otf (LOGFONT *font, Lisp_Object otf_spec);
 
 Lisp_Object intern_font_name (char *);
+#ifdef USE_W32_IME
+void fill_in_logfont (struct frame *, LOGFONT *, Lisp_Object);
+#endif /* USE_W32_IME */
 
 extern void globals_of_w32font (void);
 
diff --git a/src/w32term.c b/src/w32term.c
index 62037e3b2cd..4153d2f5293 100644
--- a/src/w32term.c
+++ b/src/w32term.c
@@ -6094,6 +6094,107 @@ w32_read_socket (struct terminal *terminal,
 	  break;
 #endif
 
+#ifdef USE_W32_IME
+	case WM_MULE_IME_STATUS:
+	  f = w32_window_to_frame (dpyinfo, msg.msg.hwnd);
+
+	  if (f && !f->iconified && f->visible)
+	    {
+	      inev.kind = NON_ASCII_KEYSTROKE_EVENT;
+	      inev.code = VK_KANJI;
+	      inev.modifiers = 0;
+	      XSETFRAME (inev.frame_or_window, f);
+	      inev.timestamp = msg.msg.time;
+	    }
+	  break;
+
+	case WM_MULE_IME_REPORT:
+	  {
+#ifdef IME_UNICODE
+	    LPWSTR lpStr;
+#else
+	    LPSTR lpStr;
+#endif
+	    struct input_event buf;
+	    HANDLE hw32_ime_string = (HANDLE) msg.msg.wParam;
+
+	    f = (struct frame *) msg.msg.lParam;
+	    if (f && !f->iconified && f->visible)
+	      {
+#ifdef IME_UNICODE
+		lpStr = (LPWSTR) hw32_ime_string;
+#else
+		lpStr = (LPSTR) hw32_ime_string;
+#endif
+		while (lpStr)
+		  {
+		    wchar_t code;
+
+		    EVENT_INIT (buf);
+		    XSETFRAME (buf.frame_or_window, f);
+		    buf.timestamp = msg.msg.time;
+		    buf.modifiers = 0;
+		    if (*lpStr)
+		      {
+#ifdef IME_UNICODE
+			if (*lpStr < 0x80)
+			  buf.kind = ASCII_KEYSTROKE_EVENT;
+			else
+			  buf.kind = MULTIBYTE_CHAR_KEYSTROKE_EVENT;
+			if ((*lpStr & 0xFC00) == 0xD800
+			    && (*(lpStr + 1) & 0xFC00) == 0xDC00)
+			  {
+			    buf.code = 0x10000
+			      + (((*lpStr & 0x3FF) << 10)
+				 | *(lpStr + 1) & 0x3FF);
+			    lpStr++;
+			  }
+			else
+			  buf.code = *(lpStr++);
+#else
+			if (IsDBCSLeadByteEx (w32_keyboard_codepage, *lpStr)) {
+			    if (!lpStr[1] ||
+				!MultiByteToWideChar (w32_keyboard_codepage, 0,
+						      lpStr, 2, &code, 1)) {
+				lpStr++;
+				continue;
+			    }
+			    lpStr += 2;
+			} else {
+			    if (!MultiByteToWideChar (w32_keyboard_codepage, 0,
+						      lpStr++, 1, &code, 1))
+			      continue;
+			}
+			buf.code = code;
+			buf.kind = buf.code < 0x80 ?
+			    ASCII_KEYSTROKE_EVENT : MULTIBYTE_CHAR_KEYSTROKE_EVENT;;
+#endif
+			kbd_buffer_store_event (&buf);
+		      }
+		    else
+		      {
+			buf.kind = NON_ASCII_KEYSTROKE_EVENT;
+			buf.code = VK_COMPEND;
+			kbd_buffer_store_event (&buf);
+			break;
+		      }
+		  }
+		HeapFree (GetProcessHeap (), 0, (LPVOID) hw32_ime_string);
+	      }
+	  }
+	  break;
+
+	case WM_MULE_IME_DEL_RANGE:
+	  del_range ((ptrdiff_t) msg.msg.wParam, (ptrdiff_t) msg.msg.lParam);
+	  Fgoto_char (make_fixnum (msg.msg.wParam));
+	  redisplay ();
+	  break;
+
+	case WM_MULE_IME_SET_FONT:
+	  w32_set_ime_logfont (msg.msg.hwnd, (struct frame *) msg.msg.wParam);
+	  break;
+#endif /* USE_W32_IME */
+
 #if 0
 	  /* These messages existed in prerelease versions of Windows 7,
 	     yet, though superseded by just WM_TOUCHMOVE (renamed
@@ -6697,7 +6798,12 @@ w32_draw_window_cursor (struct window *w, struct glyph_row *glyph_row,
 	    + WINDOW_HEADER_LINE_HEIGHT (w);
 	  w32_system_caret_mode_height = WINDOW_MODE_LINE_HEIGHT (w);
 
+#ifdef USE_W32_IME
+	  if (f && f == FRAME_DISPLAY_INFO (f)->highlight_frame)
+	    PostMessage (hwnd, WM_MULE_IMM_SET_CONVERSION_WINDOW, (WPARAM) f, 0);
+#else  /* !USE_W32_IME */
 	  PostMessage (hwnd, WM_IME_STARTCOMPOSITION, 0, 0);
+#endif /* !USE_W32_IME */
 
 	  /* If the size of the active cursor changed, destroy the old
 	     system caret.  */
@@ -8182,6 +8288,9 @@ w32_initialize (void)
     horizontal_scroll_bar_left_border = horizontal_scroll_bar_right_border
       = GetSystemMetrics (SM_CYHSCROLL);
   }
+#ifdef USE_W32_IME
+  w32_ime_control_init ();
+#endif /* USE_W32_IME */
 
   w32_get_mouse_wheel_vertical_delta ();
 }
diff --git a/src/w32term.h b/src/w32term.h
index 47be542f570..2f0eb4a3ccd 100644
--- a/src/w32term.h
+++ b/src/w32term.h
@@ -673,6 +673,8 @@ do { \
 #endif /* WM_MOUSEHWHEEL  */
 #ifndef WM_APPCOMMAND
 #define WM_APPCOMMAND 0x319
+#endif
+#ifndef GET_APPCOMMAND_LPARAM
 #define GET_APPCOMMAND_LPARAM(lParam)  (HIWORD(lParam) & 0x7fff)
 #endif
 #ifndef WM_UNICHAR
@@ -712,6 +714,100 @@ do { \
 #define WM_EMACS_IME_STATUS            (WM_EMACS_START + 26)
 #define WM_EMACS_END                   (WM_EMACS_START + 27)
 
+#ifdef USE_W32_IME
+#undef IME_UNICODE
+#define IME_UNICODE
+
+#ifndef VK_KANJI
+#define VK_KANJI 0x19
+#endif
+#ifndef VK_KANA
+#define VK_KANA  0x15
+#endif
+#define VK_COMPEND 0x1A
+
+#ifdef RECONVERSION
+#ifndef WM_IME_REQUEST
+#define WM_IME_REQUEST                  0x288
+#endif
+#ifndef IMR_COMPOSITIONWINDOW
+#define IMR_COMPOSITIONWINDOW           0x0001
+#endif
+#ifndef IMR_CANDIDATEWINDOW
+#define IMR_CANDIDATEWINDOW             0x0002
+#endif
+#ifdef IMR_COMPOSITIONFONT
+#define IMR_COMPOSITIONFONT             0x0003
+#endif
+#ifndef IMR_RECONVERTSTRING
+#define IMR_RECONVERTSTRING             0x0004
+#endif
+#ifndef IMR_CONFIRMRECONVERTSTRING
+#define IMR_CONFIRMRECONVERTSTRING      0x0005
+#endif
+#endif
+#ifndef IME_PROP_COMPLETE_ON_UNSELECT
+#define IME_PROP_COMPLETE_ON_UNSELECT 0x00100000
+#endif
+#ifndef SCS_CAP_SETRECONVERTSTRING
+#define SCS_CAP_SETRECONVERTSTRING 0x00000004
+#endif
+
+/* For internal communications
+   from window procedure to event loop. */
+#define WM_MULE_IME_REPORT         (WM_USER+2200)
+#define WM_MULE_IME_STATUS         (WM_USER+2201)
+#define WM_MULE_IME_DEL_RANGE      (WM_USER+2202)
+#define WM_MULE_IME_SET_FONT       (WM_USER+2203)
+
+/* For internal communications
+   from main thread to window procedure. */
+#define WM_MULE_IMM_MESSAGE_START             (WM_USER+2300)
+#define WM_MULE_IMM_SET_STATUS                (WM_USER+2300)
+#define WM_MULE_IMM_GET_STATUS                (WM_USER+2301)
+#if 0
+#define WM_MULE_IMM_DEAL_WITH_CONTEXT         (WM_USER+2302)
+#define WM_MULE_IMM_SET_COMPOSITION_STRING    (WM_USER+2303)
+#endif
+#define WM_MULE_IMM_GET_COMPOSITION_STRING    (WM_USER+2304)
+#define WM_MULE_IMM_SET_MODE                  (WM_USER+2305)
+#if 0
+#define WM_MULE_IMM_NOTIFY                    (WM_USER+2310)
+#define WM_MULE_IMM_GET_UNDETERMINED_STRING_LENGTH (WM_USER+2320)
+#endif
+#define WM_MULE_IMM_SET_IMEFONT		      (WM_USER+2311)
+#define WM_MULE_IMM_SET_CONVERSION_WINDOW     (WM_USER+2312)
+
+#define WM_MULE_IMM_PERFORM_RECONVERSION      (WM_USER+2320)
+
+#define WND_EXTRA_BYTES     (WND_LAST_INDEX)
+#define WM_MULE_IMM_MESSAGE_END               (WM_USER+2399)
+#define MESSAGE_IMM_COM_P(message)              \
+  (((message) >= WM_MULE_IMM_MESSAGE_START) &&  \
+   ((message) <= WM_MULE_IMM_MESSAGE_END))
+
+#ifdef RECONVERSION
+#ifndef HAVE_RECONVERTSTRING
+typedef struct tagRECONVERTSTRING {
+  DWORD dwSize;
+  DWORD dwVersion;
+  DWORD dwStrLen;
+  DWORD dwStrOffset;
+  DWORD dwCompStrLen;
+  DWORD dwCompStrOffset;
+  DWORD dwTargetStrLen;
+  DWORD dwTargetStrOffset;
+} RECONVERTSTRING, *PRECONVERTSTRING;
+#endif
+#ifndef SCS_SETRECONVERTSTRING
+#define SCS_SETRECONVERTSTRING 0x00010000
+#endif
+#ifndef SCS_QUERYRECONVERTSTRING
+#define SCS_QUERYRECONVERTSTRING 0x00020000
+#endif
+#endif /* RECONVERSION */
+#endif /* USE_W32_IME */
+
 #define WND_FONTWIDTH_INDEX    (0)
 #define WND_LINEHEIGHT_INDEX   (4)
 #define WND_BORDER_INDEX       (8)
@@ -934,3 +1030,8 @@ extern void w32_init_main_thread (void);
 #ifdef CYGWIN
 extern int w32_message_fd;
 #endif /* CYGWIN */
+
+#ifdef USE_W32_IME
+extern void w32_set_ime_logfont (HWND, struct frame *);
+extern void w32_ime_control_init (void);
+#endif /* USE_W32_IME */
diff --git a/src/window.c b/src/window.c
index ff28bac5306..387dc0fa3e0 100644
--- a/src/window.c
+++ b/src/window.c
@@ -515,6 +515,9 @@ select_window (Lisp_Object window, Lisp_Object norecord,
   struct frame *sf;
   Lisp_Object frame;
   struct frame *f;
+#ifdef USE_W32_IME
+  Lisp_Object oldwin = selected_window;
+#endif /* USE_W32_IME */
 
   CHECK_LIVE_WINDOW (window);
 
@@ -579,6 +582,11 @@ select_window (Lisp_Object window, Lisp_Object norecord,
       record_buffer (w->contents);
     }
 
+#ifdef USE_W32_IME
+  if (!NILP (Vselect_window_functions))
+    run_hook_with_args_2 (Qselect_window_functions, oldwin, window);
+#endif /* USE_W32_IME */
+
   return window;
 }
 
@@ -4256,6 +4264,18 @@ This function runs `window-scroll-functions' before running
 
   set_window_buffer (window, buffer, true, !NILP (keep_margins));
 
+#ifdef USE_W32_IME
+  if (! NILP (Vset_selected_window_buffer_functions))
+    {
+      Lisp_Object temp[4];
+      temp[0] = Qset_selected_window_buffer_functions;
+      temp[1] = tem;
+      temp[2] = window;
+      temp[3] = buffer;
+      Frun_hook_with_args (4, temp);
+    }
+#endif /* USE_W32_IME */
+
   return Qnil;
 }
 
@@ -8564,6 +8584,10 @@ syms_of_window (void)
   DEFSYM (Qwindow_size_change_functions, "window-size-change-functions");
   DEFSYM (Qwindow_buffer_change_functions, "window-buffer-change-functions");
   DEFSYM (Qwindow_selection_change_functions, "window-selection-change-functions");
+#ifdef USE_W32_IME
+  DEFSYM (Qset_selected_window_buffer_functions, "set-selected-window-buffer-functions");
+  DEFSYM (Qselect_window_functions, "select-window-functions");
+#endif /* USE_W32_IME */
   DEFSYM (Qwindowp, "windowp");
   DEFSYM (Qwindow_configuration_p, "window-configuration-p");
   DEFSYM (Qwindow_live_p, "window-live-p");
@@ -8917,6 +8941,17 @@ Note that this optimization can cause the portion of the buffer
 displayed after a scrolling operation to be somewhat inaccurate.  */);
   fast_but_imprecise_scrolling = false;
 
+#ifdef USE_W32_IME
+  DEFVAR_LISP ("set-selected-window-buffer-functions",
+	       Vset_selected_window_buffer_functions,
+	       doc: /*  */);
+  Vset_selected_window_buffer_functions = Qnil;
+  DEFVAR_LISP ("select-window-functions",
+	       Vselect_window_functions,
+	       doc: /*  */);
+  Vselect_window_functions = Qnil;
+#endif /* USE_W32_IME */
+
   defsubr (&Sselected_window);
   defsubr (&Sold_selected_window);
   defsubr (&Sminibuffer_window);
diff --git a/src/xdisp.c b/src/xdisp.c
index 566c4b211d6..3e392412816 100644
--- a/src/xdisp.c
+++ b/src/xdisp.c
@@ -13637,8 +13637,23 @@ format_mode_line_unwind_data (struct frame *target_frame,
   return vector;
 }
 
+#ifdef USE_W32_IME
+static void unwind_format_mode_line_0 (Lisp_Object vector);
 static void
 unwind_format_mode_line (Lisp_Object vector)
+{
+  specpdl_ref count = SPECPDL_INDEX ();
+
+  specbind (Qw32_ime_buffer_switch_p, Qnil);
+  unwind_format_mode_line_0 (vector);
+  unbind_to (count, Qnil);
+}
+static void
+unwind_format_mode_line_0 (Lisp_Object vector)
+#else  /* !USE_W32_IME */
+static void
+unwind_format_mode_line (Lisp_Object vector)
+#endif /* !USE_W32_IME */
 {
   Lisp_Object old_window = AREF (vector, 7);
   Lisp_Object target_frame_window = AREF (vector, 8);
@@ -13895,8 +13910,23 @@ needs_no_redisplay (struct window *w)
 /* Prepare for redisplay by updating menu-bar item lists when
    appropriate.  This can call eval.  */
 
+#ifdef USE_W32_IME
+static void prepare_menu_bars_0 (void);
+static void
+prepare_menu_bars (void)
+{
+  specpdl_ref count = SPECPDL_INDEX ();
+
+  specbind (Qw32_ime_buffer_switch_p, Qnil);
+  prepare_menu_bars_0 ();
+  unbind_to (count, Qnil);
+}
+static void
+prepare_menu_bars_0 (void)
+#else  /* !USE_W32_IME */
 static void
 prepare_menu_bars (void)
+#endif /* !USE_W32_IME */
 {
   bool all_windows = windows_or_buffers_changed || update_mode_lines;
   bool some_windows = REDISPLAY_SOME_P ();
